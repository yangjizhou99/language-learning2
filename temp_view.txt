'use client';

import { useCallback, useEffect, useMemo, useState } from 'react';
import { supabase } from '@/lib/supabase';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Textarea } from '@/components/ui/textarea';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import type {
  AlignmentMaterial,
  AlignmentSubtopic,
  AlignmentTheme,
  AlignmentKnowledgePoints,
  AlignmentPracticeScenario,
  AlignmentStandardDialogue,
} from '@/lib/alignment/types';
import {
  ALIGNMENT_GENRES,
  ALIGNMENT_LANGS,
  ALIGNMENT_LEVELS,
  ALIGNMENT_TASK_TYPES,
  ALIGNMENT_LEVEL_REQUIREMENT_COUNTS,
  ALIGNMENT_WRITING_WORD_RANGES,
} from '@/lib/alignment/constants';
import type { AlignmentGenre, AlignmentLang, AlignmentLevel, AlignmentTaskType } from '@/lib/alignment/constants';
import { Badge } from '@/components/ui/badge';
import { Loader2, RefreshCw, Sparkles, FileText, CheckCircle2, XCircle, Edit2 } from 'lucide-react';

type AlignmentMaterialWithRelations = AlignmentMaterial & {
  subtopic?: AlignmentSubtopic & {
    theme?: AlignmentTheme | null;
  } | null;
};

type GeneratedMaterial = {
  task_prompt: string;
  task_prompt_translations: Record<string, string>;
  exemplar: string;
  exemplar_translations: Record<string, string>;
  knowledge_points: AlignmentKnowledgePoints;
  requirements: Array<{ label: string; translations: Record<string, string> }>;
  standard_answer: string;
  standard_answer_translations: Record<string, string>;
  core_sentences: string[];
  rubric: Record<string, any>;
  dialogue_meta?: Record<string, any>;
  writing_meta?: Record<string, any>;
  ai_metadata?: Record<string, any>;
  practice_scenario?: AlignmentPracticeScenario;
  standard_dialogue?: AlignmentStandardDialogue;
};

const LANG_LABEL: Record<AlignmentLang, string> = {
  en: 'è‹±è¯­',
  ja: 'æ—¥è¯­',
  zh: 'ä¸­æ–‡',
};

const GENRE_LABEL: Record<AlignmentGenre, string> = {
  dialogue: 'å¯¹è¯',
  article: 'æ–‡ç« ',
  task_email: 'ä»»åŠ¡é‚®ä»¶',
  long_writing: 'é•¿å†™ä½?,
};

const TASK_LABEL: Record<AlignmentTaskType, string> = {
  dialogue: 'å¯¹è¯',
  article: 'æ–‡ç« å†™ä½œ',
  task_email: 'ä»»åŠ¡é‚®ä»¶',
  long_writing: 'é•¿å†™ä½?,
};

export default function AlignmentMaterialsPage() {
  const [materials, setMaterials] = useState<AlignmentMaterialWithRelations[]>([]);
  const [subtopics, setSubtopics] = useState<AlignmentSubtopic[]>([]);
  const [themes, setThemes] = useState<AlignmentTheme[]>([]);
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);

  const [lang, setLang] = useState<'all' | AlignmentLang>('all');
  const [status, setStatus] = useState<'all' | AlignmentMaterial['status']>('all');
  const [taskType, setTaskType] = useState<'all' | AlignmentTaskType>('all');
  const [themeFilter, setThemeFilter] = useState<string>('all');
  const [subtopicFilter, setSubtopicFilter] = useState<string>('all');
  const [search, setSearch] = useState('');
  const [onlyCurrent, setOnlyCurrent] = useState(false);

  const [generateSubtopicId, setGenerateSubtopicId] = useState<string>('');
  const [generateTaskType, setGenerateTaskType] = useState<AlignmentTaskType>('article');
  const [generateTemperature, setGenerateTemperature] = useState(0.75);
  const [generateModel, setGenerateModel] = useState('deepseek-chat');
  const [generatePreview, setGeneratePreview] = useState<GeneratedMaterial | null>(null);
  const [stageOneResult, setStageOneResult] = useState<GeneratedMaterial | null>(null);
  const [stageTwoResult, setStageTwoResult] = useState<{
    practice_scenario: AlignmentPracticeScenario | null;
    standard_dialogue: AlignmentStandardDialogue | null;
  } | null>(null);
  const [generatingStage, setGeneratingStage] = useState<null | 'stage1' | 'stage2' | 'all'>(null);
  const [translating, setTranslating] = useState(false);
  const [selectedMaterials, setSelectedMaterials] = useState<Record<string, boolean>>({});
  const [bulkAction, setBulkAction] = useState<null | 'publish' | 'translate'>(null);

  const [editing, setEditing] = useState<AlignmentMaterialWithRelations | null>(null);
  const [editOpen, setEditOpen] = useState(false);
  const [reviewNotes, setReviewNotes] = useState('');

  const getAuthHeaders = useCallback(async (): Promise<Record<string, string>> => {
    const {
      data: { session },
    } = await supabase.auth.getSession();
    const headers: Record<string, string> = {};
    if (session?.access_token) {
      headers.Authorization = `Bearer ${session.access_token}`;
    }
    return headers;
  }, []);

  const loadThemes = useCallback(async () => {
    try {
      const res = await fetch('/api/admin/alignment/themes', {
        headers: await getAuthHeaders(),
      });
      const json = await res.json();
      if (res.ok) {
        setThemes(json.items || []);
      }
    } catch (error) {
      console.error('åŠ è½½ä¸»é¢˜å¤±è´¥', error);
    }
  }, [getAuthHeaders]);

  const loadSubtopics = useCallback(async () => {
    try {
      const res = await fetch('/api/admin/alignment/subtopics', {
        headers: await getAuthHeaders(),
      });
      const json = await res.json();
      if (res.ok) {
        setSubtopics(json.items || []);
      }
    } catch (error) {
      console.error('åŠ è½½å°ä¸»é¢˜å¤±è´?, error);
    }
  }, [getAuthHeaders]);

  const loadMaterials = useCallback(async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams();
      if (lang !== 'all') params.set('lang', lang);
      if (status !== 'all') params.set('status', status);
      if (taskType !== 'all') params.set('task_type', taskType);
      if (themeFilter !== 'all') params.set('theme_id', themeFilter);
      if (subtopicFilter !== 'all') params.set('subtopic_id', subtopicFilter);
      if (search.trim()) params.set('q', search.trim());
      if (onlyCurrent) params.set('is_current', 'true');

      const res = await fetch(`/api/admin/alignment/materials?${params.toString()}`, {
        headers: await getAuthHeaders(),
      });
      const json = await res.json();
      if (res.ok) {
        setMaterials(json.items || []);
      } else {
        console.error('åŠ è½½ææ–™å¤±è´¥', json.error);
      }
    } catch (error) {
      console.error('åŠ è½½ææ–™å¤±è´¥', error);
    } finally {
      setLoading(false);
    }
  }, [lang, status, taskType, themeFilter, subtopicFilter, search, onlyCurrent, getAuthHeaders]);

  useEffect(() => {
    loadThemes();
    loadSubtopics();
  }, [loadThemes, loadSubtopics]);

  useEffect(() => {
    loadMaterials();
  }, [loadMaterials]);
  useEffect(() => {
    setSelectedMaterials({});
  }, [materials]);

  const subtopicsForGeneration = useMemo(() => {
    if (themeFilter !== 'all') {
      return subtopics.filter((s) => s.theme_id === themeFilter);
    }
    return subtopics;
  }, [subtopics, themeFilter]);

  const subtopicsForFilter = useMemo(() => {
    if (themeFilter !== 'all') {
      return subtopics.filter((s) => s.theme_id === themeFilter);
    }
    return subtopics;
  }, [subtopics, themeFilter]);

  useEffect(() => {
    if (subtopicsForGeneration.length === 0) {
      setGenerateSubtopicId('');
      return;
    }
    if (!generateSubtopicId || !subtopicsForGeneration.some((s) => s.id === generateSubtopicId)) {
      setGenerateSubtopicId(subtopicsForGeneration[0].id);
    }
  }, [subtopicsForGeneration, generateSubtopicId]);

  useEffect(() => {
    if (subtopicsForGeneration.length === 0) {
      setGenerateSubtopicId('');
      return;
    }
    if (!generateSubtopicId || !subtopicsForGeneration.some((s) => s.id === generateSubtopicId)) {
      setGenerateSubtopicId(subtopicsForGeneration[0].id);
    }
  }, [subtopicsForGeneration, generateSubtopicId]);

  useEffect(() => {
    if (subtopicsForFilter.length === 0) {
      setSubtopicFilter('all');
      return;
    }
    if (
      subtopicFilter !== 'all' &&
      !subtopicsForFilter.some((subtopic) => subtopic.id === subtopicFilter)
    ) {
      setSubtopicFilter('all');
    }
  }, [subtopicsForFilter, subtopicFilter]);

  const selectedSubtopic = useMemo(
    () => subtopics.find((s) => s.id === generateSubtopicId),
    [subtopics, generateSubtopicId],
  );

  const requirementRange = useMemo(() => {
    if (!selectedSubtopic) return null;
    return ALIGNMENT_LEVEL_REQUIREMENT_COUNTS[selectedSubtopic.level as AlignmentLevel];
  }, [selectedSubtopic]);

  const wordRange = useMemo(() => {
    if (!selectedSubtopic) return null;
    const level = selectedSubtopic.level as AlignmentLevel;
    return ALIGNMENT_WRITING_WORD_RANGES[level]?.[generateTaskType as 'article' | 'task_email' | 'long_writing'] || null;
  }, [selectedSubtopic, generateTaskType]);

  useEffect(() => {
    setStageOneResult(null);
    setStageTwoResult(null);
    setGeneratePreview(null);
    setGeneratingStage(null);
  }, [generateSubtopicId, generateTaskType]);

  const normalizeStageOne = useCallback((item: any): GeneratedMaterial | null => {
    if (!item) return null;
    const knowledge = item.knowledge_points || {};
    return {
      ...item,
      task_prompt_translations: item.task_prompt_translations || {},
      exemplar_translations: item.exemplar_translations || {},
      knowledge_points: {
        words: Array.isArray(knowledge.words) ? knowledge.words : [],
        sentences: Array.isArray(knowledge.sentences) ? knowledge.sentences : [],
      },
      requirements: Array.isArray(item.requirements)
        ? item.requirements.map((req: any) => ({
            label: req.label || '',
            translations: req.translations || {},
          }))
        : [],
      standard_answer_translations: item.standard_answer_translations || {},
      core_sentences: Array.isArray(item.core_sentences) ? item.core_sentences : [],
      rubric: item.rubric || {},
      dialogue_meta: item.dialogue_meta || {},
      writing_meta: item.writing_meta || {},
      ai_metadata: item.ai_metadata || {},
    };
  }, []);

  const isGenerating = generatingStage !== null;
  const stageOneCompleted = Boolean(stageOneResult);
  const stageTwoCompleted = Boolean(stageTwoResult);
  const targetLangs = useMemo(() => {
    if (!selectedSubtopic) return [];
    return ALIGNMENT_LANGS.filter((code) => code !== selectedSubtopic.lang);
  }, [selectedSubtopic]);

  const translationStatus = useMemo(() => {
    if (!stageOneResult || !selectedSubtopic) {
      return {
        completed: false,
        perLang: targetLangs.map((code) => ({ code, fields: [], done: false })),
      };
    }
    return {
      completed: targetLangs.every((code) => {
        const promptDone = Boolean(stageOneResult.task_prompt_translations?.[code]);
        const exemplarDone = Boolean(stageOneResult.exemplar_translations?.[code]);
        const answerDone = Boolean(stageOneResult.standard_answer_translations?.[code]);
        const wordsDone =
          Array.isArray(stageOneResult.knowledge_points?.words) &&
          stageOneResult.knowledge_points.words.every(
            (item) => item.translations && item.translations[code],
          );
        const sentencesDone =
          Array.isArray(stageOneResult.knowledge_points?.sentences) &&
          stageOneResult.knowledge_points.sentences.every(
            (item) => item.translations && item.translations[code],
          );
        return promptDone && exemplarDone && answerDone && wordsDone && sentencesDone;
      }),
      perLang: targetLangs.map((code) => {
        const fields: string[] = [];
        if (!stageOneResult.task_prompt_translations?.[code]) fields.push('ä»»åŠ¡æç¤º');
        if (!stageOneResult.exemplar_translations?.[code]) fields.push('èŒƒæ–‡');
        if (!stageOneResult.standard_answer_translations?.[code]) fields.push('æ ‡å‡†ç­”æ¡ˆ');
        const wordsMissing =
          Array.isArray(stageOneResult.knowledge_points?.words) &&
          stageOneResult.knowledge_points.words.some(
            (item) => !item.translations || !item.translations[code],
          );
        if (wordsMissing) fields.push('æ ¸å¿ƒè¯æ±‡');
        const sentencesMissing =
          Array.isArray(stageOneResult.knowledge_points?.sentences) &&
          stageOneResult.knowledge_points.sentences.some(
            (item) => !item.translations || !item.translations[code],
          );
        if (sentencesMissing) fields.push('å…³é”®å¥å‹');
        if (
          stageOneResult.practice_scenario &&
          (!stageOneResult.practice_scenario.summary_translations?.[code] ||
            !stageOneResult.practice_scenario.user_role?.translations?.[code] ||
            !stageOneResult.practice_scenario.ai_role?.translations?.[code])
        ) {
          fields.push('ç»ƒä¹ åœºæ™¯');
        }
        if (
          stageOneResult.standard_dialogue &&
          (!stageOneResult.standard_dialogue.summary_translations?.[code] ||
            stageOneResult.standard_dialogue.turns?.some(
              (turn) => !turn.translations || !turn.translations[code],
            ))
        ) {
          fields.push('æ ‡å‡†å¯¹è¯');
        }
        return {
          code,
          fields,
          done: fields.length === 0,
        };
      }),
    };
  }, [stageOneResult, targetLangs, selectedSubtopic]);

  const selectedMaterialIds = useMemo(
    () => Object.entries(selectedMaterials).filter(([, checked]) => checked).map(([id]) => id),
    [selectedMaterials],
  );
  const selectedMaterialObjects = useMemo(
    () =>
      selectedMaterialIds
        .map((id) => materials.find((item) => item.id === id))
        .filter((item): item is AlignmentMaterialWithRelations => Boolean(item)),
    [selectedMaterialIds, materials],
  );
  const canBulkTranslate = selectedMaterialObjects.some((mat) =>
    ALIGNMENT_LANGS.some((code) => code !== mat.lang),
  );

  const handleGenerateStageOne = useCallback(async () => {
    if (!generateSubtopicId) {
      alert('è¯·é€‰æ‹©å°ä¸»é¢?);
      return;
    }
    setGeneratingStage('stage1');
    setStageOneResult(null);
    setStageTwoResult(null);
    setGeneratePreview(null);
    try {
      const res = await fetch('/api/admin/alignment/materials/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(await getAuthHeaders()),
        },
        body: JSON.stringify({
          step: 'stage1',
          subtopic_id: generateSubtopicId,
          task_type: generateTaskType,
          temperature: generateTemperature,
          model: generateModel,
        }),
      });
      const json = await res.json();
      if (!res.ok) {
        throw new Error(json.error || 'ç”Ÿæˆå¤±è´¥');
      }
      const base = normalizeStageOne(json.data || json.stage1 || null);
      if (!base) {
        throw new Error('AI æœªè¿”å›æœ‰æ•ˆå†…å®?);
      }
      setStageOneResult(base);
      setGeneratePreview(base);
    } catch (error) {
      console.error(error);
      alert((error as Error).message || 'ç”Ÿæˆå¤±è´¥');
    } finally {
      setGeneratingStage(null);
    }
  }, [
    generateSubtopicId,
    generateTaskType,
    generateTemperature,
    generateModel,
    getAuthHeaders,
    normalizeStageOne,
  ]);

  const handleGenerateStageTwo = useCallback(async () => {
    if (!generateSubtopicId) {
      alert('è¯·é€‰æ‹©å°ä¸»é¢?);
      return;
    }
    if (!stageOneResult) {
      alert('è¯·å…ˆå®Œæˆæ­¥éª¤ä¸€ï¼Œç”ŸæˆåŸºç¡€ç´ æ');
      return;
    }
    setGeneratingStage('stage2');
    try {
      const res = await fetch('/api/admin/alignment/materials/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(await getAuthHeaders()),
        },
        body: JSON.stringify({
          step: 'stage2',
          subtopic_id: generateSubtopicId,
          task_type: generateTaskType,
          temperature: generateTemperature,
          model: generateModel,
          base_payload: stageOneResult,
        }),
      });
      const json = await res.json();
      if (!res.ok) {
        throw new Error(json.error || 'ç”Ÿæˆå¤±è´¥');
      }
      const data = json.data || json.stage2 || {};
      let practiceScenario: AlignmentPracticeScenario | null =
        data.practice_scenario || null;
      let standardDialogue: AlignmentStandardDialogue | null =
        data.standard_dialogue || null;
      if (practiceScenario && !Array.isArray(practiceScenario.objectives)) {
        practiceScenario.objectives = (selectedSubtopic?.objectives || []).map((obj: any) => ({
          label: obj.label || obj.title || '',
          translations: obj.translations || {},
        }));
      }
      if (standardDialogue && !Array.isArray(standardDialogue.turns)) {
        standardDialogue.turns = [];
      }
      const merged = {
        ...stageOneResult,
        practice_scenario: practiceScenario,
        standard_dialogue: standardDialogue,
      } as GeneratedMaterial;
      setStageOneResult(merged);
      setStageTwoResult({
        practice_scenario: practiceScenario ?? null,
        standard_dialogue: standardDialogue ?? null,
      });
      setGeneratePreview(merged);
    } catch (error) {
      console.error(error);
      alert((error as Error).message || 'ç”Ÿæˆå¤±è´¥');
    } finally {
      setGeneratingStage(null);
    }
  }, [
    generateSubtopicId,
    generateTaskType,
    generateTemperature,
    generateModel,
    getAuthHeaders,
    selectedSubtopic,
    stageOneResult,
  ]);

  const mergeTranslationRecords = useCallback(
    (base: Record<string, string> | null | undefined, incoming: Record<string, string> | null | undefined) => {
      const result: Record<string, string> = { ...(base || {}) };
      if (incoming) {
        Object.entries(incoming).forEach(([code, value]) => {
          if (typeof value === 'string' && value.trim()) {
            result[code] = value.trim();
          }
        });
      }
      return result;
    },
    [],
  );

  const buildTranslationPayload = useCallback((material: AlignmentMaterialWithRelations) => {
    const knowledge = material.knowledge_points || { words: [], sentences: [] };
    return {
      task_prompt: material.task_prompt,
      task_prompt_translations: material.task_prompt_translations || {},
      exemplar: material.exemplar || '',
      exemplar_translations: material.exemplar_translations || {},
      knowledge_points: {
        words: Array.isArray(knowledge.words)
          ? knowledge.words.map((item: any) => ({
              term: item?.term || item?.label || '',
              translations: item?.translations || {},
            }))
          : [],
        sentences: Array.isArray(knowledge.sentences)
          ? knowledge.sentences.map((item: any) => ({
              sentence: item?.sentence || item?.label || '',
              translations: item?.translations || {},
            }))
          : [],
      },
      requirements: Array.isArray(material.requirements)
        ? material.requirements.map((req: any) => ({
            label: req?.label || '',
            translations: req?.translations || {},
          }))
        : [],
      standard_answer: material.standard_answer || '',
      standard_answer_translations: material.standard_answer_translations || {},
      practice_scenario: material.practice_scenario || null,
      standard_dialogue: material.standard_dialogue || null,
    };
  }, []);

  const mergeTranslationIntoMaterial = useCallback(
    (
      material: AlignmentMaterialWithRelations,
      translated: any,
    ): Partial<AlignmentMaterial> => {
      const knowledge = material.knowledge_points || { words: [], sentences: [] };
      const translatedWords = Array.isArray(translated?.knowledge_points?.words)
        ? translated.knowledge_points.words
        : [];
      const translatedSentences = Array.isArray(translated?.knowledge_points?.sentences)
        ? translated.knowledge_points.sentences
        : [];

      const mergedWords = Array.isArray(knowledge.words)
        ? knowledge.words.map((item: any, idx: number) => ({
            ...item,
            term: item?.term || item?.label || translatedWords[idx]?.term || '',
            translations: mergeTranslationRecords(
              item?.translations,
              translatedWords[idx]?.translations,
            ),
          }))
        : [];

      const mergedSentences = Array.isArray(knowledge.sentences)
        ? knowledge.sentences.map((item: any, idx: number) => ({
            ...item,
            sentence: item?.sentence || item?.label || translatedSentences[idx]?.sentence || '',
            translations: mergeTranslationRecords(
              item?.translations,
              translatedSentences[idx]?.translations,
            ),
          }))
        : [];

      const mergedRequirements = Array.isArray(material.requirements)
        ? material.requirements.map((req: any, idx: number) => ({
            ...req,
            translations: mergeTranslationRecords(
              req?.translations,
              translated?.requirements?.[idx]?.translations,
            ),
          }))
        : [];

      let mergedScenario = material.practice_scenario
        ? { ...material.practice_scenario }
        : null;
      if (mergedScenario) {
        mergedScenario.summary_translations = mergeTranslationRecords(
          mergedScenario.summary_translations,
          translated?.practice_scenario?.summary_translations,
        );
        if (mergedScenario.user_role) {
          mergedScenario.user_role = {
            ...mergedScenario.user_role,
            translations: mergeTranslationRecords(
              mergedScenario.user_role.translations,
              translated?.practice_scenario?.user_role?.translations,
            ),
          };
        }
        if (mergedScenario.ai_role) {
          mergedScenario.ai_role = {
            ...mergedScenario.ai_role,
            translations: mergeTranslationRecords(
              mergedScenario.ai_role.translations,
              translated?.practice_scenario?.ai_role?.translations,
            ),
          };
        }
        if (typeof mergedScenario.context_notes === 'string') {
          mergedScenario.context_notes_translations = mergeTranslationRecords(
            mergedScenario.context_notes_translations,
            translated?.practice_scenario?.context_notes_translations,
          );
        }
        if (Array.isArray(mergedScenario.objectives)) {
          mergedScenario.objectives = mergedScenario.objectives.map((obj: any, idx: number) => ({
            ...obj,
            translations: mergeTranslationRecords(
              obj?.translations,
              translated?.practice_scenario?.objectives?.[idx]?.translations,
            ),
          }));
        }
      }

      let mergedDialogue = material.standard_dialogue
        ? { ...material.standard_dialogue }
        : null;
      if (mergedDialogue) {
        mergedDialogue.summary_translations = mergeTranslationRecords(
          mergedDialogue.summary_translations,
          translated?.standard_dialogue?.summary_translations,
        );
        if (Array.isArray(mergedDialogue.turns)) {
          mergedDialogue.turns = mergedDialogue.turns.map((turn: any, idx: number) => ({
            ...turn,
            translations: mergeTranslationRecords(
              turn?.translations,
              translated?.standard_dialogue?.turns?.[idx]?.translations,
            ),
          }));
        }
      }

      return {
        id: material.id,
        subtopic_id: material.subtopic_id,
        lang: material.lang,
        task_type: material.task_type,
        status: material.status,
        review_status: material.review_status,
        version: material.version,
        is_current: material.is_current,
        task_prompt: material.task_prompt,
        task_prompt_translations: mergeTranslationRecords(
          material.task_prompt_translations,
          translated?.task_prompt_translations,
        ),
        exemplar: material.exemplar || '',
        exemplar_translations: mergeTranslationRecords(
          material.exemplar_translations,
          translated?.exemplar_translations,
        ),
        knowledge_points: {
          words: mergedWords,
          sentences: mergedSentences,
        },
        requirements: mergedRequirements,
        standard_answer: material.standard_answer || '',
        standard_answer_translations: mergeTranslationRecords(
          material.standard_answer_translations,
          translated?.standard_answer_translations,
        ),
        core_sentences: material.core_sentences || [],
        rubric: material.rubric || {},
        dialogue_meta: material.dialogue_meta || {},
        writing_meta: material.writing_meta || {},
        ai_metadata: material.ai_metadata || {},
        practice_scenario: mergedScenario,
        standard_dialogue: mergedDialogue,
      };
    },
    [mergeTranslationRecords],
  );

  const handleGenerateAll = useCallback(async () => {
    if (!generateSubtopicId) {
      alert('è¯·é€‰æ‹©å°ä¸»é¢?);
      return;
    }
    setGeneratingStage('all');
    setStageTwoResult(null);
    setStageOneResult(null);
    setGeneratePreview(null);
    try {
      const res = await fetch('/api/admin/alignment/materials/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(await getAuthHeaders()),
        },
        body: JSON.stringify({
          step: 'all',
          subtopic_id: generateSubtopicId,
          task_type: generateTaskType,
          temperature: generateTemperature,
          model: generateModel,
        }),
      });
      const json = await res.json();
      if (!res.ok) {
        throw new Error(json.error || 'ç”Ÿæˆå¤±è´¥');
      }
      const item = normalizeStageOne(json.item || null);
      if (!item) {
        throw new Error('AI æœªè¿”å›æœ‰æ•ˆå†…å®?);
      }
      if (item.practice_scenario && !Array.isArray(item.practice_scenario.objectives)) {
        item.practice_scenario.objectives = (selectedSubtopic?.objectives || []).map(
          (obj: any) => ({
            label: obj.label || obj.title || '',
            translations: obj.translations || {},
          }),
        );
      }
      if (item.standard_dialogue && !Array.isArray(item.standard_dialogue.turns)) {
        item.standard_dialogue.turns = [];
      }
      setStageOneResult(item);
      setStageTwoResult({
        practice_scenario: item.practice_scenario ?? null,
        standard_dialogue: item.standard_dialogue ?? null,
      });
      setGeneratePreview(item);
    } catch (error) {
      console.error(error);
      alert((error as Error).message || 'ç”Ÿæˆå¤±è´¥');
    } finally {
      setGeneratingStage(null);
    }
  }, [
    generateSubtopicId,
    generateTaskType,
    generateTemperature,
    generateModel,
    getAuthHeaders,
    normalizeStageOne,
    selectedSubtopic,
  ]);

  const handleGenerateTranslations = useCallback(async () => {
    if (!stageOneResult || !selectedSubtopic) {
      alert('è¯·å…ˆå®Œæˆæ­¥éª¤ä¸€');
      return;
    }
    setTranslating(true);
    try {
      const res = await fetch('/api/admin/alignment/materials/translate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(await getAuthHeaders()),
        },
        body: JSON.stringify({
          lang: selectedSubtopic.lang,
          model: generateModel,
          payload: stageOneResult,
        }),
      });
      const json = await res.json();
      if (!res.ok) {
        throw new Error(json.error || 'ç¿»è¯‘ç”Ÿæˆå¤±è´¥');
      }
      const merged = normalizeStageOne(json.item || stageOneResult) || stageOneResult;
      setStageOneResult(merged);
      if (merged.practice_scenario || merged.standard_dialogue) {
        setStageTwoResult({
          practice_scenario: merged.practice_scenario || null,
          standard_dialogue: merged.standard_dialogue || null,
        });
      }
      setGeneratePreview(merged);
    } catch (error) {
      console.error(error);
      alert((error as Error).message || 'ç¿»è¯‘ç”Ÿæˆå¤±è´¥');
    } finally {
      setTranslating(false);
    }
  }, [stageOneResult, selectedSubtopic, generateModel, getAuthHeaders, normalizeStageOne]);

  const toggleMaterialSelection = useCallback((id: string, checked: boolean) => {
    setSelectedMaterials((prev) => {
      const next = { ...prev };
      if (checked) {
        next[id] = true;
      } else {
        delete next[id];
      }
      return next;
    });
  }, []);

  const toggleSelectAllVisible = useCallback(() => {
    if (selectedMaterialIds.length === materials.length) {
      setSelectedMaterials({});
      return;
    }
    const next: Record<string, boolean> = {};
    materials.forEach((item) => {
      next[item.id] = true;
    });
    setSelectedMaterials(next);
  }, [materials, selectedMaterialIds.length]);

  const handleBulkPublish = useCallback(async () => {
    if (selectedMaterialIds.length === 0) {
      alert('è¯·å…ˆé€‰æ‹©è¦æ“ä½œçš„è®­ç»ƒåŒ?);
      return;
    }
    setBulkAction('publish');
    try {
      const headers = await getAuthHeaders();
      for (const id of selectedMaterialIds) {
        const res = await fetch('/api/admin/alignment/materials', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...headers,
          },
          body: JSON.stringify({
            action: 'review',
            id,
            status: 'active',
            review_status: 'approved',
            review_notes: null,
            is_current: true,
          }),
        });
        const json = await res.json();
        if (!res.ok) {
          throw new Error(json.error || 'æ‰¹é‡å‘å¸ƒå¤±è´¥');
        }
      }
      alert('é€‰ä¸­çš„è®­ç»ƒåŒ…å·²å‘å¸?);
      setSelectedMaterials({});
      await loadMaterials();
    } catch (error) {
      console.error(error);
      alert((error as Error).message || 'æ‰¹é‡å‘å¸ƒå¤±è´¥');
    } finally {
      setBulkAction(null);
    }
  }, [selectedMaterialIds, getAuthHeaders, loadMaterials]);

  const handleBulkTranslateSelected = useCallback(async () => {
    if (selectedMaterialObjects.length === 0) {
      alert('è¯·å…ˆé€‰æ‹©è¦ç¿»è¯‘çš„è®­ç»ƒåŒ?);
      return;
    }
    setBulkAction('translate');
    try {
      const headers = await getAuthHeaders();
      for (const material of selectedMaterialObjects) {
        const availableTargets = ALIGNMENT_LANGS.filter((code) => code !== material.lang);
        if (availableTargets.length === 0) {
          continue;
        }
        const payload = buildTranslationPayload(material);
        const res = await fetch('/api/admin/alignment/materials/translate', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...headers,
          },
          body: JSON.stringify({
            lang: material.lang,
            payload,
          }),
        });
        const json = await res.json();
        if (!res.ok) {
          throw new Error(json.error || 'ç¿»è¯‘ç”Ÿæˆå¤±è´¥');
        }
        const merged = mergeTranslationIntoMaterial(material, json.item || payload);
        await fetch('/api/admin/alignment/materials', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...headers,
          },
          body: JSON.stringify({
            action: 'upsert',
            item: merged,
          }),
        });
      }
      alert('ç¿»è¯‘å·²è¡¥é½?);
      setSelectedMaterials({});
      await loadMaterials();
    } catch (error) {
      console.error(error);
      alert((error as Error).message || 'ç¿»è¯‘å¤±è´¥');
    } finally {
      setBulkAction(null);
    }
  }, [
    selectedMaterialObjects,
    getAuthHeaders,
    buildTranslationPayload,
    mergeTranslationIntoMaterial,
    loadMaterials,
  ]);

  const handleSaveGenerated = useCallback(async () => {
    if (!stageOneResult || !selectedSubtopic) {
      alert('è¯·å…ˆç”ŸæˆåŸºç¡€ç´ æ');
      return;
    }
    if (generateTaskType === 'dialogue' && !stageOneResult.practice_scenario) {
      alert('è¯·å…ˆç”Ÿæˆç»ƒä¹ åœºæ™¯ä¸æ ‡å‡†å¯¹è¯ï¼ˆæ­¥éª¤äºŒï¼‰');
      return;
    }
    const finalPreview = generatePreview || stageOneResult;
    setSaving(true);
    try {
      const payload: Partial<AlignmentMaterial> = {
        subtopic_id: selectedSubtopic.id,
        lang: selectedSubtopic.lang,
        task_type: generateTaskType,
        status: 'pending_review',
        review_status: 'pending',
        task_prompt: finalPreview.task_prompt,
        task_prompt_translations: finalPreview.task_prompt_translations || {},
        exemplar: finalPreview.exemplar,
        exemplar_translations: finalPreview.exemplar_translations || {},
        knowledge_points: {
          words: finalPreview.knowledge_points?.words ?? [],
          sentences: finalPreview.knowledge_points?.sentences ?? [],
        },
        requirements: (finalPreview.requirements || []).map((req) => ({
          label: req.label || '',
          translations: req.translations || {},
        })),
        standard_answer: finalPreview.standard_answer,
        standard_answer_translations: finalPreview.standard_answer_translations || {},
        core_sentences: finalPreview.core_sentences || [],
        rubric: finalPreview.rubric || {},
        dialogue_meta: finalPreview.dialogue_meta || {},
        writing_meta: finalPreview.writing_meta || {},
        ai_metadata: finalPreview.ai_metadata || {},
        practice_scenario:
          finalPreview.practice_scenario ||
          stageTwoResult?.practice_scenario ||
          {},
        standard_dialogue:
          finalPreview.standard_dialogue ||
          stageTwoResult?.standard_dialogue || { summary: '', turns: [] },
      };

      const res = await fetch('/api/admin/alignment/materials', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(await getAuthHeaders()),
        },
        body: JSON.stringify({ action: 'upsert', item: payload }),
      });
      const json = await res.json();
      if (!res.ok) {
        throw new Error(json.error || 'ä¿å­˜å¤±è´¥');
      }
      setGeneratePreview(null);
      setStageOneResult(null);
      setStageTwoResult(null);
      await loadMaterials();
      alert('å·²ä¿å­˜ä¸ºå¾…å®¡æ ¸è‰ç¨?);
    } catch (error) {
      console.error(error);
      alert((error as Error).message || 'ä¿å­˜å¤±è´¥');
    } finally {
      setSaving(false);
    }
  }, [
    stageOneResult,
    generatePreview,
    selectedSubtopic,
    generateTaskType,
    stageTwoResult,
    getAuthHeaders,
    loadMaterials,
  ]);

  const openEdit = useCallback((material: AlignmentMaterialWithRelations) => {
    setEditing(material);
    setReviewNotes(material.review_notes || '');
    setEditOpen(true);
  }, []);

  const handleSaveEdit = useCallback(async () => {
    if (!editing) return;
    setSaving(true);
    try {
      const res = await fetch('/api/admin/alignment/materials', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(await getAuthHeaders()),
        },
        body: JSON.stringify({ action: 'upsert', item: editing }),
      });
      const json = await res.json();
      if (!res.ok) {
        throw new Error(json.error || 'ä¿å­˜å¤±è´¥');
      }
      setEditOpen(false);
      await loadMaterials();
    } catch (error) {
      console.error(error);
      alert((error as Error).message || 'ä¿å­˜å¤±è´¥');
    } finally {
      setSaving(false);
    }
  }, [editing, getAuthHeaders, loadMaterials]);

  const handleReview = useCallback(
    async (id: string, action: 'approve' | 'reject') => {
      setSaving(true);
      try {
        const res = await fetch('/api/admin/alignment/materials', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(await getAuthHeaders()),
          },
          body: JSON.stringify({
            action: 'review',
            id,
            status: action === 'approve' ? 'active' : 'draft',
            review_status: action === 'approve' ? 'approved' : 'rejected',
            review_notes: reviewNotes || null,
            is_current: action === 'approve',
          }),
        });
        const json = await res.json();
        if (!res.ok) {
          throw new Error(json.error || 'æ“ä½œå¤±è´¥');
        }
        setEditOpen(false);
        await loadMaterials();
      } catch (error) {
        console.error(error);
        alert((error as Error).message || 'æ“ä½œå¤±è´¥');
      } finally {
        setSaving(false);
      }
    },
    [getAuthHeaders, loadMaterials, reviewNotes],
  );

  const renderRequirementRange = () => {
    if (!requirementRange) return null;
    return (
      <span className="text-xs text-muted-foreground">
        è¦æ±‚æ•°é‡å»ºè®®ï¼š{requirementRange[0]}~{requirementRange[1]} æ?      </span>
    );
  };

  const renderWordRange = () => {
    if (!wordRange) return null;
    return (
      <span className="text-xs text-muted-foreground">
        å­—æ•°ç›®æ ‡ï¼š{wordRange[0]}~{wordRange[1]} è¯?      </span>
    );
  };

  return (
    <main className="max-w-7xl mx-auto p-6 space-y-6">
      <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-semibold">å¯¹é½ç»ƒä¹  Â· è®­ç»ƒåŒ…ç”Ÿæˆä¸å®¡æ ¸</h1>
          <p className="text-sm text-muted-foreground">
            ä¸ºå°ä¸»é¢˜ç”Ÿæˆå®Œæ•´çš„ç»ƒä¹ ææ–™ï¼Œå®¡æ ¸å¹¶å‘å¸ƒï¼Œå¯¹åº”çš„ä»»åŠ¡ä¸è¯„åˆ†æ ‡å‡†ä¼šæä¾›ç»™å­¦å‘˜ã€?          </p>
        </div>
        <div className="flex items-center gap-2">
          <Button variant="outline" onClick={loadMaterials} disabled={loading}>
            <RefreshCw className={`w-4 h-4 mr-1 ${loading ? 'animate-spin' : ''}`} />
            åˆ·æ–°
          </Button>
        </div>
      </div>

      <Card>
        <CardHeader className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
          <CardTitle className="flex items-center gap-2">
            <Sparkles className="w-5 h-5 text-purple-500" />
            AI ç”Ÿæˆè®­ç»ƒåŒ?          </CardTitle>
          <div className="flex flex-wrap gap-2 text-xs text-muted-foreground">
            {renderRequirementRange()}
            {renderWordRange()}
          </div>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            <div className="space-y-2">
              <Label>é€‰æ‹©ä¸»é¢˜</Label>
              <Select value={themeFilter} onValueChange={setThemeFilter}>
                <SelectTrigger>
                  <SelectValue placeholder="ç­›é€‰ä¸»é¢? />
                </SelectTrigger>
                <SelectContent className="max-h-72">
                  <SelectItem value="all">å…¨éƒ¨ä¸»é¢˜</SelectItem>
                  {themes.map((theme) => (
                    <SelectItem key={theme.id} value={theme.id}>
                      {theme.title} Â· {LANG_LABEL[theme.lang]} Â· L{theme.level} Â· {GENRE_LABEL[theme.genre]}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label>é€‰æ‹©å°ä¸»é¢?/Label>
              <Select value={generateSubtopicId} onValueChange={setGenerateSubtopicId}>
                <SelectTrigger>
                  <SelectValue placeholder="é€‰æ‹©å°ä¸»é¢? />
                </SelectTrigger>
                <SelectContent className="max-h-72">
                  {subtopicsForGeneration.map((subtopic) => (
                    <SelectItem key={subtopic.id} value={subtopic.id}>
                      {subtopic.title} Â· L{subtopic.level}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label>ä»»åŠ¡ç±»å‹</Label>
              <Select value={generateTaskType} onValueChange={(val) => setGenerateTaskType(val as AlignmentTaskType)}>
                <SelectTrigger>
                  <SelectValue placeholder="ä»»åŠ¡ç±»å‹" />
                </SelectTrigger>
                <SelectContent>
                  {ALIGNMENT_TASK_TYPES.map((type) => (
                    <SelectItem key={type} value={type}>
                      {TASK_LABEL[type]}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label>Temperature</Label>
              <Input
                type="number"
                min={0}
                max={1}
                step={0.1}
                value={generateTemperature}
                onChange={(e) => setGenerateTemperature(Math.max(0, Math.min(1, Number(e.target.value))))}
              />
            </div>
            <div className="space-y-2">
              <Label>æ¨¡å‹</Label>
              <Select value={generateModel} onValueChange={setGenerateModel}>
                <SelectTrigger>
                  <SelectValue placeholder="é€‰æ‹©æ¨¡å‹" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="deepseek-chat">deepseek-chat</SelectItem>
                  <SelectItem value="deepseek-reasoner">deepseek-reasoner</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
          <div className="flex flex-wrap gap-2">
            <Button onClick={handleGenerateStageOne} disabled={isGenerating || !generateSubtopicId}>
              {generatingStage === 'stage1' && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
              æ­¥éª¤ä¸€ï¼šç”ŸæˆåŸºç¡€ç´ æ
            </Button>
            <Button
              variant="secondary"
              onClick={handleGenerateStageTwo}
              disabled={isGenerating || !stageOneCompleted}
            >
              {generatingStage === 'stage2' && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
              æ­¥éª¤äºŒï¼šç”Ÿæˆåœºæ™¯/å¯¹è¯
            </Button>
            <Button variant="outline" onClick={handleGenerateAll} disabled={isGenerating || !generateSubtopicId}>
              {generatingStage === 'all' && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
              ä¸€é”®ç”Ÿæˆï¼ˆå¯é€‰ï¼‰
            </Button>
          </div>
          <div className="flex flex-wrap items-center gap-2 text-xs text-muted-foreground">
            <Badge variant={stageOneCompleted ? 'default' : 'outline'}>
              æ­¥éª¤ä¸€ Â· {stageOneCompleted ? 'å·²å®Œæˆ? : 'å¾…æ‰§è¡?}
            </Badge>
            <Badge variant={stageTwoCompleted ? 'default' : 'outline'}>
              æ­¥éª¤äº?Â· {stageTwoCompleted ? 'å·²å®Œæˆ? : 'å¾…æ‰§è¡?}
            </Badge>
          </div>

          {generatePreview && (
            <Card className="border border-dashed">
              <CardHeader className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
                <CardTitle className="text-base flex items-center gap-2">
                  <FileText className="w-4 h-4" />
                  ç”Ÿæˆé¢„è§ˆ
                </CardTitle>
                <div className="flex items-center gap-2">
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={handleGenerateTranslations}
                    disabled={translating || !stageOneCompleted}
                  >
                    {translating && <Loader2 className="w-4 h-4 mr-1 animate-spin" />}
                    ç”Ÿæˆç¿»è¯‘å­—æ®µ
                  </Button>
                </div>
              </CardHeader>
              <CardContent className="space-y-3 text-sm text-muted-foreground">
                {targetLangs.length > 0 && (
                  <div className="rounded-md border border-dashed border-muted-foreground/40 bg-muted/20 p-3 text-xs space-y-2">
                    <div className="font-medium text-foreground">ç¿»è¯‘çŠ¶æ€?/div>
                    {translationStatus.perLang.map((item) => (
                      <div key={item.code} className="flex items-start gap-2">
                        <Badge variant={item.done ? 'default' : 'secondary'} className="mt-0.5">
                          {item.code.toUpperCase()} {item.done ? 'å·²å®Œæˆ? : 'å¾…ç¿»è¯?}
                        </Badge>
                        {item.fields.length > 0 ? (
                          <span className="text-muted-foreground">
                            éœ€è¡¥å……ï¼š{item.fields.join(' / ')}
                          </span>
                        ) : (
                          <span className="text-muted-foreground">æ‰€æœ‰å­—æ®µå·²å®Œæˆ</span>
                        )}
                      </div>
                    ))}
                    <p className="text-muted-foreground">
                      ä½¿ç”¨â€œç”Ÿæˆç¿»è¯‘å­—æ®µâ€å¯ä¸€æ¬¡æ€§è¡¥é½æ‰€æœ‰è¯­è¨€ï¼Œéœ€è¦æ—¶å¯åå¤æ‰§è¡Œä»¥è¦†ç›–æœ€æ–°å†…å®¹ã€?                    </p>
                  </div>
                )}
                <div>
                  <span className="font-medium text-foreground">ä»»åŠ¡æç¤ºï¼?/span>
                  <pre className="whitespace-pre-wrap text-sm mt-1">{generatePreview.task_prompt}</pre>
                </div>
                <div>
                  <span className="font-medium text-foreground">èŒƒæ–‡ï¼?/span>
                  <pre className="whitespace-pre-wrap text-sm mt-1">{generatePreview.exemplar}</pre>
                </div>
                <div className="space-y-2">
                  <span className="font-medium text-foreground">æ ¸å¿ƒè¯æ±‡ï¼?/span>
                  {generatePreview.knowledge_points?.words?.length ? (
                    <ul className="space-y-1 text-sm leading-relaxed">
                      {generatePreview.knowledge_points.words.map((item, idx) => (
                        <li key={`word-${idx}`} className="border rounded px-3 py-2 bg-muted/40">
                          <div className="font-medium text-foreground">{item.term}</div>
                          <div className="text-xs text-muted-foreground mt-1 space-y-0.5">
                            {Object.entries(item.translations || {}).length === 0
                              ? 'æš‚æ— ç¿»è¯‘'
                              : Object.entries(item.translations || {}).map(([code, value]) => (
                                  <div key={code}>
                                    <span className="uppercase font-semibold mr-1">{code}</span>
                                    {value}
                                  </div>
                                ))}
                          </div>
                        </li>
                      ))}
                    </ul>
                  ) : (
                    <p className="text-xs text-muted-foreground">æš‚æ— è¯æ±‡</p>
                  )}
                </div>
                <div className="space-y-2">
                  <span className="font-medium text-foreground">å…³é”®å¥å‹ï¼?/span>
                  {generatePreview.knowledge_points?.sentences?.length ? (
                    <ul className="space-y-1 text-sm leading-relaxed">
                      {generatePreview.knowledge_points.sentences.map((item, idx) => (
                        <li key={`sentence-${idx}`} className="border rounded px-3 py-2 bg-muted/30">
                          <div className="font-medium text-foreground">{item.sentence}</div>
                          <div className="text-xs text-muted-foreground mt-1 space-y-0.5">
                            {Object.entries(item.translations || {}).length === 0
                              ? 'æš‚æ— ç¿»è¯‘'
                              : Object.entries(item.translations || {}).map(([code, value]) => (
                                  <div key={code}>
                                    <span className="uppercase font-semibold mr-1">{code}</span>
                                    {value}
                                  </div>
                                ))}
                          </div>
                        </li>
                      ))}
                    </ul>
                  ) : (
                    <p className="text-xs text-muted-foreground">æš‚æ— å¥å‹</p>
                  )}
                </div>
                <div>
                  <span className="font-medium text-foreground">è¦æ±‚ï¼?/span>
                  <ul className="list-disc list-inside">
                    {generatePreview.requirements?.map((req, idx) => (
                      <li key={idx}>{req.label}</li>
                    ))}
                  </ul>
                </div>
                <div>
                  <span className="font-medium text-foreground">æ ‡å‡†ç­”æ¡ˆï¼?/span>
                  <pre className="whitespace-pre-wrap text-sm mt-1">{generatePreview.standard_answer}</pre>
                </div>
                {generatePreview.practice_scenario && (
                  <div className="space-y-2">
                    <span className="font-medium text-foreground">ç»ƒä¹ åœºæ™¯ï¼?/span>
                    <div className="border rounded px-3 py-2 bg-muted/40 text-sm leading-relaxed">
                      <div>{generatePreview.practice_scenario.summary}</div>
                      <div className="text-xs text-muted-foreground mt-2">
                        å­¦å‘˜è§’è‰²ï¼š{generatePreview.practice_scenario.user_role?.name} Â·{' '}
                        {generatePreview.practice_scenario.user_role?.description}
                      </div>
                      <div className="text-xs text-muted-foreground">
                        AI è§’è‰²ï¼š{generatePreview.practice_scenario.ai_role?.name} Â·{' '}
                        {generatePreview.practice_scenario.ai_role?.description}
                      </div>
                      <div className="text-xs text-muted-foreground">
                        å¼€åœºå‘è¨€ï¼š{generatePreview.practice_scenario.kickoff_speaker === 'ai' ? 'AI' : 'å­¦å‘˜'}
                      </div>
                      {Array.isArray(generatePreview.practice_scenario.objectives) &&
                        generatePreview.practice_scenario.objectives.length > 0 && (
                          <ul className="text-xs text-muted-foreground mt-1 space-y-1 list-disc list-inside">
                            {generatePreview.practice_scenario.objectives.map((obj, idx) => (
                              <li key={`obj-${idx}`}>{obj.label}</li>
                            ))}
                          </ul>
                        )}
                    </div>
                  </div>
                )}
                {generatePreview.standard_dialogue?.turns?.length ? (
                  <div className="space-y-2">
                    <span className="font-medium text-foreground">æ ‡å‡†å¯¹è¯ï¼?/span>
                    <ul className="space-y-1 text-sm leading-relaxed">
                      {generatePreview.standard_dialogue.turns.map((turn, idx) => (
                        <li key={`turn-${idx}`} className="border rounded px-3 py-2 bg-muted/30">
                          <div className="font-medium">{turn.speaker === 'ai' ? 'AI' : 'å­¦å‘˜'}ï¼?/div>
                          <div>{turn.text}</div>
                          {turn.objective_refs?.length ? (
                            <div className="text-xs text-muted-foreground mt-1">
                              å…³è”ç›®æ ‡ï¼š{turn.objective_refs.join(', ')}
                            </div>
                          ) : null}
                        </li>
                      ))}
                    </ul>
                  </div>
                ) : null}
                <div className="flex gap-2">
                  <Button onClick={handleSaveGenerated} disabled={saving}>
                    {saving && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
                    ä¿å­˜ä¸ºè‰ç¨?                  </Button>
                  <Button
                    variant="outline"
                    onClick={() => {
                      setGeneratePreview(null);
                      setStageOneResult(null);
                      setStageTwoResult(null);
                    }}
                  >
                    æ¸…ç©º
                  </Button>
                </div>
              </CardContent>
            </Card>
          )}
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>ç­›é€‰æ¡ä»?/CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-4">
            <div className="space-y-2">
              <Label>è¯­è¨€</Label>
              <Select value={lang} onValueChange={(val) => setLang(val as typeof lang)}>
                <SelectTrigger>
                  <SelectValue placeholder="è¯­è¨€" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">å…¨éƒ¨</SelectItem>
                  {ALIGNMENT_LANGS.map((code) => (
                    <SelectItem key={code} value={code}>
                      {LANG_LABEL[code]}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label>çŠ¶æ€?/Label>
              <Select value={status} onValueChange={(val) => setStatus(val as typeof status)}>
                <SelectTrigger>
                  <SelectValue placeholder="çŠ¶æ€? />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">å…¨éƒ¨</SelectItem>
                  <SelectItem value="draft">è‰ç¨¿</SelectItem>
                  <SelectItem value="pending_review">å¾…å®¡æ ?/SelectItem>
                  <SelectItem value="active">å·²å‘å¸?/SelectItem>
                  <SelectItem value="archived">å·²å½’æ¡?/SelectItem>
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label>æ‰€å±ä¸»é¢?/Label>
              <Select value={themeFilter} onValueChange={setThemeFilter}>
                <SelectTrigger>
                  <SelectValue placeholder="ç­›é€‰ä¸»é¢? />
                </SelectTrigger>
                <SelectContent className="max-h-72">
                  <SelectItem value="all">å…¨éƒ¨ä¸»é¢˜</SelectItem>
                  {themes.map((theme) => (
                    <SelectItem key={theme.id} value={theme.id}>
                      {theme.title} Â· {LANG_LABEL[theme.lang]} Â· L{theme.level}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label>æ‰€å±å°ä¸»é¢˜</Label>
              <Select value={subtopicFilter} onValueChange={setSubtopicFilter}>
                <SelectTrigger>
                  <SelectValue placeholder="ç­›é€‰å°ä¸»é¢˜" />
                </SelectTrigger>
                <SelectContent className="max-h-72">
                  <SelectItem value="all">å…¨éƒ¨å°ä¸»é¢?/SelectItem>
                  {subtopicsForFilter.map((subtopic) => (
                    <SelectItem key={subtopic.id} value={subtopic.id}>
                      {subtopic.title} Â· L{subtopic.level}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label>ä»»åŠ¡ç±»å‹</Label>
              <Select value={taskType} onValueChange={(val) => setTaskType(val as typeof taskType)}>
                <SelectTrigger>
                  <SelectValue placeholder="ä»»åŠ¡ç±»å‹" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">å…¨éƒ¨</SelectItem>
                  {ALIGNMENT_TASK_TYPES.map((type) => (
                    <SelectItem key={type} value={type}>
                      {TASK_LABEL[type]}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label>å…³é”®è¯?/Label>
              <Input value={search} onChange={(e) => setSearch(e.target.value)} placeholder="æ ‡é¢˜/å†…å®¹æœç´¢" />
            </div>
            <div className="space-y-2">
              <Label>åªçœ‹å½“å‰ç‰ˆæœ¬</Label>
              <Select value={onlyCurrent ? 'true' : 'false'} onValueChange={(val) => setOnlyCurrent(val === 'true')}>
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="false">å…¨éƒ¨</SelectItem>
                  <SelectItem value="true">ä»…å½“å‰ç‰ˆæœ?/SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-col gap-2">
          <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-2">
            <CardTitle>è®­ç»ƒåŒ…åˆ—è¡?/CardTitle>
            <div className="flex flex-wrap items-center gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={toggleSelectAllVisible}
                disabled={materials.length === 0}
              >
                {selectedMaterialIds.length === materials.length && materials.length > 0
                  ? 'å–æ¶ˆå…¨é€?
                  : 'å…¨é€‰å½“å‰åˆ—è¡?}
              </Button>
              <Button
                size="sm"
                onClick={handleBulkPublish}
                disabled={selectedMaterialIds.length === 0 || bulkAction !== null}
              >
                {bulkAction === 'publish' && <Loader2 className="w-4 h-4 mr-1 animate-spin" />}
                å‘å¸ƒé€‰ä¸­
              </Button>
              <Button
                size="sm"
                variant="secondary"
                onClick={handleBulkTranslateSelected}
                disabled={
                  selectedMaterialIds.length === 0 || bulkAction !== null || !canBulkTranslate
                }
              >
                {bulkAction === 'translate' && <Loader2 className="w-4 h-4 mr-1 animate-spin" />}
                ç¿»è¯‘é€‰ä¸­
              </Button>
              <div className="text-xs text-muted-foreground">
                å·²é€?{selectedMaterialIds.length} é¡?              </div>
            </div>
          </div>
          <div className="text-sm text-muted-foreground">å…?{materials.length} æ¡è®°å½?/div>
        </CardHeader>
        <CardContent>
          {loading ? (
            <div className="py-10 flex justify-center">
              <Loader2 className="w-6 h-6 animate-spin" />
            </div>
          ) : materials.length === 0 ? (
            <div className="py-10 text-center text-muted-foreground">æš‚æ— æ•°æ®</div>
          ) : (
            <div className="space-y-4">
              {materials.map((material) => (
                <Card
                  key={material.id}
                  className={`border ${material.review_status === 'pending' ? 'border-yellow-200' : material.review_status === 'approved' ? 'border-green-200' : ''}`}
                >
                  <CardContent className="p-4 space-y-3">
                    <div className="flex flex-col md:flex-row md:items-start md:justify-between gap-3">
                      <div className="flex items-start gap-3">
                        <input
                          type="checkbox"
                          className="mt-1 h-4 w-4"
                          checked={Boolean(selectedMaterials[material.id])}
                          onChange={(e) => toggleMaterialSelection(material.id, e.target.checked)}
                        />
                        <div>
                          <div className="flex items-center gap-2 flex-wrap">
                            <h3 className="text-lg font-semibold">
                              {material.subtopic?.title || 'æœªå…³è”å°ä¸»é¢˜'}
                            </h3>
                            <Badge variant="outline">{LANG_LABEL[material.lang as AlignmentLang]}</Badge>
                            <Badge variant="outline">{TASK_LABEL[material.task_type as AlignmentTaskType]}</Badge>
                            {material.status === 'active' && <Badge variant="default">å·²å‘å¸?/Badge>}
                            {material.review_status === 'pending' && (
                              <Badge variant="secondary">å¾…å®¡æ ?/Badge>
                            )}
                            {material.is_current && (
                              <Badge variant="outline" className="border-green-500 text-green-600">
                                å½“å‰ç‰ˆæœ¬
                              </Badge>
                            )}
                          </div>
                          {material.subtopic?.theme && (
                            <div className="text-xs text-muted-foreground mt-1">
                              ä¸»é¢˜ï¼š{material.subtopic.theme.title} Â· L{material.subtopic.theme.level} Â·{' '}
                              {GENRE_LABEL[material.subtopic.theme.genre as AlignmentGenre]}
                            </div>
                          )}
                          <div className="text-sm text-muted-foreground mt-2 line-clamp-3">
                            {material.task_prompt}
                          </div>
                        </div>
                      </div>
                      <div>
                        <div className="flex items-center gap-2">
                          <Button size="sm" variant="outline" onClick={() => openEdit(material)}>
                            <Edit2 className="w-4 h-4 mr-1" />
                            æŸ¥çœ‹ / å®¡æ ¸
                          </Button>
                        </div>
                    </div>
                    <div className="text-xs text-muted-foreground">
                      æ›´æ–°æ—¶é—´ï¼š{new Date(material.updated_at).toLocaleString()}
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          )}
        </CardContent>
      </Card>

      <Dialog open={editOpen} onOpenChange={setEditOpen}>
        <DialogContent className="max-w-3xl">
          <DialogHeader>
            <DialogTitle>è®­ç»ƒåŒ…è¯¦æƒ?/DialogTitle>
          </DialogHeader>
          {editing && (
            <div className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                <div>
                  <Label>ä»»åŠ¡æç¤º</Label>
                  <Textarea
                    rows={3}
                    value={editing.task_prompt}
                    onChange={(e) =>
                      setEditing((prev) => (prev ? { ...prev, task_prompt: e.target.value } : prev))
                    }
                  />
                </div>
                <div>
                  <Label>èŒƒæ–‡</Label>
                  <Textarea
                    rows={3}
                    value={editing.exemplar || ''}
                    onChange={(e) =>
                      setEditing((prev) => (prev ? { ...prev, exemplar: e.target.value } : prev))
                    }
                  />
                </div>
              </div>
              <div>
                <Label>çŸ¥è¯†ç‚?JSON</Label>
                <Textarea
                  rows={6}
                  value={JSON.stringify(editing.knowledge_points || {}, null, 2)}
                  onChange={(e) => {
                    try {
                      const value = JSON.parse(e.target.value);
                      setEditing((prev) => (prev ? { ...prev, knowledge_points: value } : prev));
                    } catch {
                      // ignore
                    }
                  }}
                />
              </div>
              <div>
                <Label>ç»ƒä¹ åœºæ™¯ JSON</Label>
                <Textarea
                  rows={5}
                  value={JSON.stringify(editing.practice_scenario || {}, null, 2)}
                  onChange={(e) => {
                    try {
                      const value = JSON.parse(e.target.value);
                      setEditing((prev) => (prev ? { ...prev, practice_scenario: value } : prev));
                    } catch {
                      // ignore
                    }
                  }}
                />
              </div>
              <div>
                <Label>è¦æ±‚ JSON</Label>
                <Textarea
                  rows={5}
                  value={JSON.stringify(editing.requirements || [], null, 2)}
                  onChange={(e) => {
                    try {
                      const value = JSON.parse(e.target.value);
                      setEditing((prev) => (prev ? { ...prev, requirements: value } : prev));
                    } catch {
                      // ignore
                    }
                  }}
                />
              </div>
              <div>
                <Label>æ ‡å‡†å¯¹è¯ JSON</Label>
                <Textarea
                  rows={5}
                  value={JSON.stringify(editing.standard_dialogue || {}, null, 2)}
                  onChange={(e) => {
                    try {
                      const value = JSON.parse(e.target.value);
                      setEditing((prev) => (prev ? { ...prev, standard_dialogue: value } : prev));
                    } catch {
                      // ignore
                    }
                  }}
                />
              </div>
              <div>
                <Label>æ ‡å‡†ç­”æ¡ˆ</Label>
                <Textarea
                  rows={4}
                  value={editing.standard_answer || ''}
                  onChange={(e) =>
                    setEditing((prev) => (prev ? { ...prev, standard_answer: e.target.value } : prev))
                  }
                />
              </div>
              <div>
                <Label>Rubric JSON</Label>
                <Textarea
                  rows={4}
                  value={JSON.stringify(editing.rubric || {}, null, 2)}
                  onChange={(e) => {
                    try {
                      const value = JSON.parse(e.target.value);
                      setEditing((prev) => (prev ? { ...prev, rubric: value } : prev));
                    } catch {
                      // ignore
                    }
                  }}
                />
              </div>
              <div className="space-y-2">
                <Label>å®¡æ ¸å¤‡æ³¨</Label>
                <Textarea
                  rows={3}
                  value={reviewNotes}
                  onChange={(e) => setReviewNotes(e.target.value)}
                  placeholder="å¯è®°å½•å®¡æ ¸æ„è§æˆ–æ”¹è¿›å»ºè®®"
                />
              </div>
              <div className="flex flex-wrap justify-between gap-2">
                <div className="flex gap-2">
                  <Button variant="outline" onClick={() => setEditOpen(false)}>
                    å…³é—­
                  </Button>
                  <Button onClick={handleSaveEdit} disabled={saving}>
                    {saving && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
                    ä¿å­˜ä¿®æ”¹
                  </Button>
                </div>
                <div className="flex gap-2">
                  <Button
                    variant="destructive"
                    onClick={() => handleReview(editing.id, 'reject')}
                    disabled={saving}
                  >
                    {saving && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
                    <XCircle className="w-4 h-4 mr-1" />
                    é©³å›
                  </Button>
                  <Button onClick={() => handleReview(editing.id, 'approve')} disabled={saving}>
                    {saving && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
                    <CheckCircle2 className="w-4 h-4 mr-1" />
                    é€šè¿‡å¹¶å‘å¸?                  </Button>
                </div>
              </div>
            </div>
          )}
        </DialogContent>
      </Dialog>
    </main>
  );
}

